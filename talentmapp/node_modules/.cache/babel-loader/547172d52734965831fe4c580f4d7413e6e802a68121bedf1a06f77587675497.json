{"ast":null,"code":"import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { maxRecommendedTextures } from '../../renderers/shared/texture/utils/maxRecommendedTextures.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.blendMode = \"normal\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    this.uid = uid(\"batcher\");\n    this.dirty = true;\n    this.batchIndex = 0;\n    this.batches = [];\n    // specifics.\n    this._vertexSize = 6;\n    this._elements = [];\n    this._batchPool = [];\n    this._batchPoolIndex = 0;\n    this._textureBatchPool = [];\n    this._textureBatchPoolIndex = 0;\n    options = {\n      ..._Batcher.defaultOptions,\n      ...options\n    };\n    const {\n      vertexSize,\n      indexSize\n    } = options;\n    this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n    this.indexBuffer = new Uint16Array(indexSize);\n    this._maxTextures = maxRecommendedTextures();\n  }\n  begin() {\n    this.batchIndex = 0;\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    this._batchPoolIndex = 0;\n    this._textureBatchPoolIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject.indexStart = this.indexSize;\n    batchableObject.location = this.attributeSize;\n    batchableObject.batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0) return false;\n    batchableObject.textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    batchableObject.packAttributes(this.attributeBuffer.float32View, this.attributeBuffer.uint32View, batchableObject.location, batchableObject.textureId);\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n    textureBatch.clear();\n    if (!elements[this.elementStart]) return;\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const iBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n    const maxTextures = this._maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const blendModeChange = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !blendModeChange) {\n        element.textureId = source._textureBindLocation;\n        size += element.indexSize;\n        element.packAttributes(f32, u32, element.location, element.textureId);\n        element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        element.batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || blendModeChange) {\n        this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n        textureBatch.clear();\n        batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n        ++BATCH_TICK;\n      }\n      element.textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element.batch = batch;\n      size += element.indexSize;\n      element.packAttributes(f32, u32, element.location, element.textureId);\n      element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size) return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length) return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      this.batches[i].destroy();\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i].batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  vertexSize: 4,\n  indexSize: 6\n};\nlet Batcher = _Batcher;\nexport { Batch, Batcher };","map":{"version":3,"names":["Batch","constructor","renderPipeId","action","start","size","blendMode","canBundle","destroy","textures","gpuBindGroup","bindGroup","batcher","BATCH_TICK","_Batcher","options","uid","dirty","batchIndex","batches","_vertexSize","_elements","_batchPool","_batchPoolIndex","_textureBatchPool","_textureBatchPoolIndex","defaultOptions","vertexSize","indexSize","attributeBuffer","ViewableBuffer","indexBuffer","Uint16Array","_maxTextures","maxRecommendedTextures","begin","elementSize","elementStart","attributeSize","_batchIndexStart","_batchIndexSize","add","batchableObject","indexStart","location","checkAndUpdateTexture","texture","textureId","batch","ids","_source","updateElement","packAttributes","float32View","uint32View","break","instructionSet","elements","textureBatch","BatchTextureArray","clear","firstElement","getAdjustedBlendModeBlend","_resizeAttributeBuffer","length","_resizeIndexBuffer","f32","u32","iBuffer","maxTextures","i","element","source","adjustedBlendMode","blendModeChange","_batchTick","_textureBindLocation","packIndex","count","_finishBatch","finish","ensureAttributeBuffer","ensureIndexBuffer","newSize","Math","max","newArrayBuffer","fastCopy","rawBinaryData","newIndexBuffer","Uint32Array","BYTES_PER_ELEMENT","buffer","Batcher"],"sources":["/Users/florianmorina/Desktop/TalentMapp/Talentmapp/talentmapp/node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts"],"sourcesContent":["import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { maxRecommendedTextures } from '../../renderers/shared/texture/utils/maxRecommendedTextures';\nimport { BatchTextureArray } from './BatchTextureArray';\n\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray;\n\n    public blendMode: BLEND_MODES = 'normal';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\nexport interface BatchableObject\n{\n    indexStart: number;\n\n    packAttributes: (\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    ) => void;\n    packIndex: (indexBuffer: IndexBufferArray, index: number, indicesOffset: number) => void;\n\n    texture: Texture;\n    blendMode: BLEND_MODES;\n    vertexSize: number;\n    indexSize: number;\n\n    // stored for efficient updating..\n    textureId: number;\n    location: number; // location in the buffer\n    batcher: Batcher;\n    batch: Batch;\n\n    roundPixels: 0 | 1;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @ignore\n */\nexport interface BatcherOptions\n{\n    /** The size of the vertex buffer. */\n    vertexSize?: number;\n    /** The size of the index buffer. */\n    indexSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * @ignore\n */\nexport class Batcher\n{\n    public static defaultOptions: BatcherOptions = {\n        vertexSize: 4,\n        indexSize: 6,\n    };\n\n    public uid = uid('batcher');\n    public attributeBuffer: ViewableBuffer;\n    public indexBuffer: IndexBufferArray;\n\n    public attributeSize: number;\n    public indexSize: number;\n    public elementSize: number;\n    public elementStart: number;\n\n    public dirty = true;\n\n    public batchIndex = 0;\n    public batches: Batch[] = [];\n\n    // specifics.\n    private readonly _vertexSize: number = 6;\n\n    private _elements: BatchableObject[] = [];\n\n    private readonly _batchPool: Batch[] = [];\n    private _batchPoolIndex = 0;\n    private readonly _textureBatchPool: BatchTextureArray[] = [];\n    private _textureBatchPoolIndex = 0;\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n    private readonly _maxTextures: number;\n\n    constructor(options: BatcherOptions = {})\n    {\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { vertexSize, indexSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n\n        this.indexBuffer = new Uint16Array(indexSize);\n\n        this._maxTextures = maxRecommendedTextures();\n    }\n\n    public begin()\n    {\n        this.batchIndex = 0;\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n        this._batchPoolIndex = 0;\n        this._textureBatchPoolIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableObject)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject.indexStart = this.indexSize;\n        batchableObject.location = this.attributeSize;\n        batchableObject.batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.vertexSize) * this._vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableObject, texture: Texture): boolean\n    {\n        const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject.textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableObject)\n    {\n        this.dirty = true;\n\n        batchableObject.packAttributes(\n            this.attributeBuffer.float32View,\n            this.attributeBuffer.uint32View,\n            batchableObject.location, batchableObject.textureId);\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        // ++BATCH_TICK;\n        const elements = this._elements;\n\n        let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n\n        textureBatch.clear();\n\n        // length 0??!! (we broke without ading anything)\n        if (!elements[this.elementStart]) return;\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const iBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n        let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n\n        const maxTextures = this._maxTextures;\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const blendModeChange = blendMode !== adjustedBlendMode;\n\n            if (source._batchTick === BATCH_TICK && !blendModeChange)\n            {\n                element.textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n                element.packAttributes(f32, u32, element.location, element.textureId);\n                element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n\n                element.batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= maxTextures || blendModeChange)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n\n                textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n                textureBatch.clear();\n\n                batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n                ++BATCH_TICK;\n            }\n\n            element.textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element.batch = batch;\n\n            size += element.indexSize;\n            element.packAttributes(f32, u32, element.location, element.textureId);\n            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            this.batches[i].destroy();\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i].batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}